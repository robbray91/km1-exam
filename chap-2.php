<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Chapter 2: What is a system development lifecycle?</title>
    <link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.5.2/css/bootstrap.min.css">
    <style>
        body {
            font-family: Arial, sans-serif;
            color: #333;
            background-color: #f8f9fa;
            padding: 20px;
        }

        h1 {
            color: #007bff;
            font-size: 28px;
            margin-bottom: 20px;
        }

        h2 {
            color: #28a745;
            font-size: 24px;
            margin-bottom: 10px;
        }

        h3 {
            color: #dc3545;
            font-size: 20px;
            margin-bottom: 10px;
        }

        p {
            font-size: 16px;
            margin-bottom: 10px;
        }

        ul {
            margin-bottom: 10px;
        }

        li {
            margin-bottom: 5px;
        }
    </style>
</head>

<body>

    <!-- Navigation Links -->
    <nav class="navbar navbar-expand-lg navbar-light bg-light">
        <div class="container" id="container">
            <a class="navbar-brand" href="homepage.php">Homepage</a>
        </div>
    </nav>

    <div class="container">
        <h1>Chapter 2: What is a system development lifecycle?</h1>

        <p>SDLC is a plan for making computer systems, like a game.</p>
        <p>It's like building a treehouse: plan, build, test, and use.</p>
        <p>Steps can vary in order.</p>
        <p>SDLC turns ideas into real systems.</p>

        <h2>1. Feasibility Study:</h2>
        <p>Check if it's worth it, like money for a treehouse.</p>

        <h2>2. Requirements Engineering:</h2>
        <p>List what your treehouse needs.</p>

        <h2>3. Design:</h2>
        <p>Create a safe plan, like a blueprint.</p>

        <h2>4. Development:</h2>
        <p>Build with materials.</p>

        <h2>5. Testing:</h2>
        <p>Ensure safety and fun.</p>

        <h2>6. Implementation:</h2>
        <p>Share it carefully.</p>

        <hr>

        <h3>The different elements of a system development lifecycle to be considered:</h3>

        <h2>1. Context:</h2>
        <p>Understand the situation, like planning a party; consider complexity, skills, and adaptability.</p>

        <h2>2. Lifecycle:</h2>
        <p>Linear (step-by-step) or iterative (versions and improvements) roadmaps.</p>

        <h2>3. Process:</h2>
        <p>Step-by-step actions in projects.</p>

        <h2>4. Roles:</h2>
        <p>Leaders, experts, doers ensure clarity.</p>

        <h2>5. Deliverables:</h2>
        <p>Created project components, like homework.</p>

        <h2>6. Techniques:</h2>
        <p>Special tools and methods for design and testing, like art supplies.</p>

        <hr>

        <h3>Bit more info about system development lifecycles:</h3>

        <h2>1. Development lifecycles are like recipes; choose the right one.</h2>
        <p>Consider project type, ingredients, and audience.</p>

        <h2>2. Adjust the plan for unique qualities.</h2>
        <p>Most methods work, but some suit specific projects.</p>

        <h2>3. Explore recipes for computer systems in this chapter.</h2>

        <hr>

        <h3>What exactly is meant by system development lifecycle?</h3>

        <h2>1. Two Ways to Build:</h2>
        <p>Build a computer system like baking a cake: linear (recipe-like) or evolutionary (experimenting).</p>

        <h2>2. Five Basic Recipes:</h2>
        <p>Similar to cake recipes: Waterfall (step-by-step), V Model (focus on testing), Incremental (add parts over time), Iterative (improve in cycles), Spiral (flexible planning).</p>

        <h2>3. Life After Baking:</h2>
        <p>Like caring for a cake, computer systems need ongoing support and maintenance (updates, security) known as "through life costs." It's a continuous process, not just a one-time thing.</p>

        <hr>

        <h3>System Development Lifecycle in comparison to System Lifecycle:</h3>

        <h2>System Development Lifecycle (SDLC):</h2>
        <p>- It's like baking a cake from scratch with a plan, ingredients, baking, and serving.</p>
        <p>- Has a budget and timeline, success means a ready cake.</p>
        <p>- Job ends when the cake is ready.</p>

        <h2>System Lifecycle:</h2>
        <p>- Like caring for a baked cake â€“ store, add frosting, fix, and improve.</p>
        <p>- No fixed budget or timeline; keep making it better.</p>
        <p>- Mainly about time, money, and changes.</p>
        <p>- Some cakes last long, so caring for them can be costly.</p>
        <p>- Think about long-term care, not just baking.</p>

        <hr>

        <h3>Linear Approach Explained:</h3>

        <p>- It's like a strict path with ordered steps.</p>
        <p>- Checkpoints ensure each step is completed and approved.</p>
        <p>- Ideal for known, stable projects with little change.</p>
        <p>- Works well for large or small teams, keeping things clear and organized.</p>
        <p>- Efficient with small teams and fresh information.</p>

        <h3>Strengths of Linear Approach:</h3>
        <ul>
            <li>Clear stages and structure.</li>
            <li>Agreed upfront details.</li>
            <li>Suitable for complex projects.</li>
            <li>Excellent for detailed designs.</li>
            <li>Cost and scope control.</li>
            <li>Simple for small tasks.</li>
        </ul>

        <h3>Weaknesses of Linear Approach:</h3>
        <ul>
            <li>Perfection required in each stage.</li>
            <li>Lengthy timelines for complex projects.</li>
            <li>Difficult with changing requirements.</li>
            <li>Value only at project end.</li>
            <li>Little value if early cancellation.</li>
        </ul>

        <hr>

        <h3>Evolutionary Approaches in Software Development:</h3>

        <p>- Focus on gradual progress with prototypes or iterations.</p>
        <p>- Ideal for unclear requirements and early delivery.</p>
        <p>- Agile is a popular example.</p>
        <p>- Perfect for innovation, complexity, and high risks.</p>
        <p>- Justifies funding, speeds market entry, and identifies risks.</p>
        <p>- Allows early project stoppage without major losses.</p>
        <p>- Emphasizes working software demonstrations and understanding.</p>

        <h3>Strengths of Evolutionary Approach:</h3>
        <ul>
            <li>Early value delivery to customers.</li>
            <li>Adaptability to complex and changing requirements.</li>
            <li>Enhanced user collaboration.</li>
            <li>Start with minimal development and refine later.</li>
        </ul>

        <h3>Weaknesses of Evolutionary Approach:</h3>
        <ul>
            <li>Management complexity, especially in complex projects.</li>
            <li>Potential scope creep without careful management.</li>
            <li>Higher overall costs due to multiple iterations.</li>
            <li>Risk of over-promising on early functionality.</li>
        </ul>

        <hr>

        <h3>Waterfall Approach Explained:</h3>

        <p>- Linear lifecycle with sequential stages.</p>
        <p>- Each step completed before moving on.</p>
        <p>- Best for well-understood and stable requirements.</p>
        <p>- Challenging and costly for changes after sign-off.</p>
        <p>- Provides project management control, easy to grasp.</p>
        <p>- Potential for long development times, delayed working software, and reduced customer collaboration.</p>
        <p>- Success relies on strong project management, accurate estimation, and thorough design.</p>

        <h3>Strengths of Waterfall Approach:</h3>
        <ul>
            <li>Ideal for well-understood requirements.</li>
            <li>Strong project management control.</li>
            <li>Simple and easy to understand.</li>
        </ul>

        <h3>Weaknesses of Waterfall Approach:</h3>
        <ul>
            <li>Costly to manage changes.</li>
            <li>Delays in delivering working software.</li>
            <li>Poor estimation impacts cost and schedule.</li>
            <li>Limited customer collaboration.</li>
            <li>Customer buy-in may lack in long projects.</li>
        </ul>

        <hr>

        <h3>V Model Explained:</h3>

        <p>- A Waterfall variation, divides into project definition and verification/validation.</p>
        <p>- Emphasizes testing throughout, creating test artifacts with requirements.</p>
        <p>- Ensures high-quality system delivery, suitable for safety-critical and complex projects.</p>
        <p>- Divides responsibilities among multiple teams/suppliers in complex tasks.</p>

        <h3>Strengths of V Model:</h3>
        <ul>
            <li>High-quality system delivery.</li>
            <li>Suited for safety-critical systems.</li>
            <li>Early testing focus.</li>
            <li>Adaptable for complex projects and multiple teams/suppliers.</li>
        </ul>

        <h3>Weaknesses of V Model:</h3>
        <ul>
            <li>More complex to manage than traditional Waterfall.</li>
            <li>Not ideal for rapidly changing requirements.</li>
            <li>May require extensive planning and documentation.</li>
        </ul>

        <hr>

        <h3>Extended 'V' Model Explained:</h3>

        <p>- Builds on traditional 'V' model with feasibility and benefits realization stages.</p>
        <p>- Focuses on measuring actual business benefits, not just verifying requirements.</p>
        <p>- More popular and versatile than the simple Waterfall model.</p>
        <p>- Effective for complex or high-quality systems and large-scale projects.</p>

        <h3>Strengths of Extended 'V' Model:</h3>
        <ul>
            <li>Strong testing focus for high-quality products.</li>
            <li>Suitable for complex or high-quality systems.</li>
            <li>Adaptable for complex supply chains and distributed teams.</li>
            <li>Strong project management capabilities.</li>
            <li>Scalable for managing extremely large and complex systems.</li>
        </ul>

        <h3>Weaknesses of Extended 'V' Model:</h3>
        <ul>
            <li>Higher testing and integration costs.</li>
            <li>Increased cost and impact of changes as the project progresses.</li>
            <li>Longer time required for early stages due to testing artifacts.</li>
            <li>Late delivery of the working system, reducing customer involvement.</li>
            <li>Increased risk if right-hand side planning, especially system integration, isn't done properly.</li>
        </ul>

        <hr>
        
        <h3>Incremental Lifecycle Explained:</h3>
        <p>- Linear approach with flexible delivery.</p>
        <p>- High-priority requirements delivered early.</p>
        <p>- Increments can be parallel; working solution early.</p>
        <p>- Useful for rapid time to market, stable core architecture, and clear desired functionality.</p>

        <h3>Strengths of Incremental Lifecycle:</h3>
        <ul>
            <li>Early access to functional elements.</li>
            <li>Suitable for rapid deployment.</li>
            <li>Allows choice of delivery order.</li>
            <li>Cost reduction if early functionality suffices.</li>
        </ul>

        <h3>Weaknesses of Incremental Lifecycle:</h3>
        <ul>
            <li>Extra costs for multiple releases.</li>
            <li>Release-related expenses (training, deployment, outages).</li>
            <li>Regression testing against earlier functionality.</li>
            <li>Weigh benefits against additional costs.</li>
        </ul>

        <hr>

        <h3>Spiral Lifecycle Explained:</h3>
        <p>- Evolutionary approach with cycles of planning, risk analysis, engineering, and evaluation.</p>
        <p>- Suitable for high-risk and complex projects.</p>
        <p>- Iterative cycles address evolving requirements and risks.</p>
        <p>- Emphasizes early identification and mitigation of problems.</p>
        <p>- Typically used for large software development projects.</p>
        <p>- Offers adaptability and flexibility.</p>

        <h3>Strengths of Spiral Lifecycle:</h3>
        <ul>
            <li>Effective for high-risk and complex projects.</li>
            <li>Risk assessment and mitigation from the start.</li>
            <li>Ongoing requirement adjustments.</li>
            <li>Early problem identification.</li>
            <li>Suitable for large software projects.</li>
            <li>Adaptability and flexibility.</li>
        </ul>

        <h3>Weaknesses of Spiral Lifecycle:</h3>
        <ul>
            <li>Requires significant resources.</li>
            <li>Complex to manage and costly.</li>
            <li>Potential for extended project duration.</li>
            <li>Smaller projects may find it too heavy.</li>
            <li>Demands skilled and experienced teams.</li>
            <li>Documentation overhead.</li>
        </ul>

        <hr>

        <h3>Agile and Its Impact:</h3>
        <p>- Agile Manifesto published in 2001 by 17 IT professionals.</p>
        <p>- Emphasizes individuals, working software, customer collaboration, and responding to change.</p>
        <p>- Led to flexible and iterative software development methods.</p>
        <p>- Replaced traditional linear lifecycles like Waterfall and 'V' model.</p>
        <p>- Known for producing working software quickly, adaptability, and lightweight nature.</p>
        <p>- Proper implementation is crucial, with a focus on rules and processes.</p>
        <p>- Integration with traditional approaches is possible, following Agile principles.</p>
        <p>- Challenges in larger teams, complex systems, regulatory requirements, contractual commitments, complex user environments, and subcontracting into non-Agile projects.</p>
        <p>- Hybrid approaches combining Agile with other methods offer flexibility, structure, and control.</p>

        <hr>

        <h3>What is SSADM?</h3>
        <ol>
            <li>SSADM is like a recipe for computer systems.</li>
            <li>It's used in government to understand big business situations.</li>
            <li>It has seven stages, like following steps.</li>
            <li>Models (drawings) help to understand things.</li>
            <li>Three main model types: data and rules, data flow, entity event.</li>
            <li>It checks if an idea works (stage 0).</li>
            <li>Then, it looks at what's happening now (stage 1).</li>
            <li>They think about different ways to do things (stage 2).</li>
            <li>Next, they write down what the system should do (stage 3).</li>
            <li>Then, they decide on the technical stuff (stage 4).</li>
            <li>They design how it works in theory (stage 5).</li>
            <li>Finally, they figure out how to build it (stage 6).</li>
            <li>Sometimes they go back to earlier stages if things change.</li>
        </ol>

        <hr>

        <h3>What is DSDM?</h3>
        <ol>
            <li>DSDM is a flexible way to make computer things.</li>
            <li>It's divided into three parts: planning, building, and finishing up.</li>
            <li>The building part has five steps: feasibility, business study, design, build, and implementation.</li>
            <li>DSDM follows eight rules to focus on what the business needs and finish on time.</li>
            <li>It's like a recipe for projects where business stuff is important, emphasizing project management.</li>
        </ol>

        <hr>

        <h3>What is SCRUM?</h3>
        <ol>
            <li>Scrum, a popular way to create computer things, focuses on planning and tracking work. It started in 1995 and uses unique ideas.</li>
            <li>Scrum has three main roles: the "product owner," the business voice; the "development team," the doers; and the "Scrum master," problem solver.</li>
            <li>The "Product Backlog" is a list of tasks in order of importance, managed by the product owner.</li>
            <li>Scrum uses short "Sprints," usually two weeks, to make a working product. Daily "Scrum" meetings discuss issues.</li>
            <li>The whole team collaborates to complete tasks related to planning, design, or building software.</li>
            <li>Scrum suits 5-9 skilled team members, but missing skills can be a problem. Sometimes it focuses too much on work and not on business benefits.</li>
            <li>For bigger projects, be cautious when scaling Scrum. Good connections with stakeholders are essential for success.</li>
        </ol>

        <hr>

        <h3>What is Rational Unified Process (RUP)?</h3>
        <ol>
            <li>RUP: Software rules by Rational Software (now IBM), helps organize work.</li>
            <li>Step-by-step like Spiral model, flexible for different projects.</li>
            <li>Four phases: Inception, Elaboration, Construction, Transition.</li>
            <li>Six workflows: business modeling, requirements, analysis, design, implementation, testing, deployment.</li>
            <li>Complex and flexible, best for big projects; use only what's needed.</li>
            <li>Liked by developers, uses UML for planning and designing software.</li>
        </ol>

        <hr>

        <h3>What is Lean Software Development?</h3>
        <ol>
            <li>LSD stems from lean manufacturing, focuses on efficiency and waste reduction.</li>
            <li>Introduced by Mary and Tom Poppendieck in 2003.</li>
            <li>Key principles: customer focus, motivated teams, waste elimination, rapid learning, fast delivery, built-in quality, continuous improvement, holistic optimization.</li>
            <li>Complements other methods like Scrum.</li>
            <li>Other approaches include Kanban, Xtreme Programming, AgileUP, DAD, Rapid App Development, Crystal Methods, and Scrumban. Choose the one that suits your project.</li>
        </ol>

        <hr>

        <h3>How to choose an approach</h3>
        <ol>
            <li>Problem Complexity: Simple = Waterfall. Complex = RUP, 'V' model, or Spiral.</li>
            <li>Team Experience: Experienced with a method = use it. Newer team = choose carefully.</li>
            <li>Requirements Stability: Stable = any approach. Rapid changes = Scrum or iterative methods.</li>
            <li>Delivery Speed & Quality: Quick and complete system = linear methods. Evolutionary for other cases.</li>
            <li>Customer Involvement: Low involvement = linear. High involvement = Scrum or evolutionary.</li>
            <li>Uniqueness: Unique projects = evolutionary methods.</li>
            <li>Regulatory Needs: For regulatory compliance, consider Waterfall, 'V' model, or DSDM for Agile.</li>
        </ol>

        <hr>
        <h2>End of Chapter 2 notes</h2>
        <a href="#container">Back to top of page</a>
    </div>

    <script src="https://code.jquery.com/jquery-3.5.1.slim.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@popperjs/core@2.5.4/dist/umd/popper.min.js"></script>
    <script src="https://stackpath.bootstrapcdn.com/bootstrap/4.5.2/js/bootstrap.min.js"></script>
</body>

</html>
